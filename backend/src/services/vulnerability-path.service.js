/**
 * Vulnerability Path Service
 * Traces exploit chains from deep dependencies to project entry points
 */

class VulnerabilityPathTracer {
    constructor() {
        this.dependencyGraph = new Map();
        this.entryPoints = [
            'index.js', 'server.js', 'app.js', 'main.js',
            'index.ts', 'server.ts', 'app.ts', 'main.ts'
        ];
    }

    /**
     * Build dependency graph from package.json and imports
     */
    buildDependencyGraph(packageJson, importMap) {
        this.dependencyGraph.clear();

        // Add direct dependencies
        const deps = {
            ...packageJson.dependencies,
            ...packageJson.devDependencies
        };

        for (const [pkg, version] of Object.entries(deps)) {
            this.dependencyGraph.set(pkg, {
                version,
                type: 'direct',
                importedBy: [],
                imports: [],
                usedIn: []
            });
        }

        // Add transitive dependencies from import map
        for (const [file, imports] of Object.entries(importMap)) {
            for (const imp of imports) {
                if (!this.dependencyGraph.has(imp)) {
                    this.dependencyGraph.set(imp, {
                        version: 'unknown',
                        type: 'transitive',
                        importedBy: [],
                        imports: [],
                        usedIn: []
                    });
                }

                const node = this.dependencyGraph.get(imp);
                if (!node.usedIn.includes(file)) {
                    node.usedIn.push(file);
                }
            }
        }

        return this.dependencyGraph;
    }

    /**
     * Trace exploit path from vulnerable dependency to entry points
     */
    traceExploitPath(vulnerablePkg, vulnerability) {
        const paths = [];
        const visited = new Set();

        // Find all paths from vulnerable package to entry points
        for (const entryPoint of this.entryPoints) {
            const pathsToEntry = this.findPaths(
                vulnerablePkg,
                entryPoint,
                [],
                visited
            );

            paths.push(...pathsToEntry);
        }

        // Analyze reachability and risk for each path
        return paths.map(path => ({
            path,
            exploitFlow: this.generateExploitFlow(path, vulnerability),
            reachability: this.calculateReachability(path),
            riskScore: this.calculatePathRisk(path, vulnerability),
            publicAPI: this.identifyPublicAPI(path),
            mitigations: this.suggestMitigations(path, vulnerability)
        }));
    }

    /**
     * Find all paths from source to target using DFS
     */
    findPaths(source, target, currentPath, visited) {
        if (visited.has(source)) return [];

        const newPath = [...currentPath, source];

        // Check if we reached an entry point or target file
        if (source.includes(target) || this.isEntryPoint(source)) {
            return [newPath];
        }

        visited.add(source);
        const paths = [];

        // Get files that import this package
        const node = this.dependencyGraph.get(source);
        if (node && node.usedIn) {
            for (const parent of node.usedIn) {
                const subPaths = this.findPaths(parent, target, newPath, new Set(visited));
                paths.push(...subPaths);
            }
        }

        visited.delete(source);
        return paths;
    }

    /**
     * Check if file is an entry point
     */
    isEntryPoint(file) {
        return this.entryPoints.some(entry => file.endsWith(entry));
    }

    /**
     * Generate detailed exploit flow description
     */
    generateExploitFlow(path, vulnerability) {
        const flow = [];

        flow.push({
            step: 1,
            component: path[0],
            description: `Vulnerability exists in ${path[0]}: ${vulnerability.title || 'Unknown CVE'}`,
            severity: vulnerability.severity || 'high',
            cve: vulnerability.cve
        });

        for (let i = 1; i < path.length; i++) {
            flow.push({
                step: i + 1,
                component: path[i],
                description: `${path[i - 1]} is imported by ${path[i]}`,
                dataFlow: this.analyzeDataFlow(path[i - 1], path[i])
            });
        }

        flow.push({
            step: flow.length + 1,
            component: 'User Input',
            description: `Exploit reaches public API where user input can trigger vulnerability`,
            attackVector: this.identifyAttackVector(path, vulnerability)
        });

        return flow;
    }

    /**
     * Analyze data flow between two components
     */
    analyzeDataFlow(from, to) {
        // Simplified analysis - would use AST in production
        return {
            direct: true,
            sanitized: false,
            transformations: [],
            note: `Data flows from ${from} to ${to} without sanitization`
        };
    }

    /**
     * Identify attack vector for exploit
     */
    identifyAttackVector(path, vulnerability) {
        const vectors = {
            xss: 'User-supplied HTML/JS in request body or query parameters',
            sqli: 'Malicious SQL operators in request parameters',
            rce: 'Shell metacharacters in user input',
            pathTraversal: 'Path traversal sequences (../) in file parameters',
            ssrf: 'Attacker-controlled URLs in request',
            prototypePotion: 'JSON with __proto__ keys in request body',
            xxe: 'Malicious XML entities in uploaded files',
            deserialization: 'Crafted serialized objects in cookies/sessions'
        };

        const vulnType = vulnerability.type || vulnerability.title?.toLowerCase() || '';
        
        for (const [type, vector] of Object.entries(vectors)) {
            if (vulnType.includes(type)) {
                return vector;
            }
        }

        return 'User input through HTTP request parameters, headers, or body';
    }

    /**
     * Calculate reachability score (how easily user input reaches vulnerability)
     */
    calculateReachability(path) {
        let score = 100;

        // Decrease score based on path length
        score -= (path.length - 1) * 10;

        // Check if path goes through entry point
        const hasEntryPoint = path.some(p => this.isEntryPoint(p));
        if (!hasEntryPoint) {
            score -= 30;
        }

        // Check for sanitization/validation layers
        const hasSanitization = path.some(p => 
            p.includes('validator') || 
            p.includes('sanitize') ||
            p.includes('joi') ||
            p.includes('yup')
        );

        if (hasSanitization) {
            score -= 40;
        }

        return Math.max(0, Math.min(100, score));
    }

    /**
     * Calculate risk score for path
     */
    calculatePathRisk(path, vulnerability) {
        let risk = 0;

        // Base risk from vulnerability severity
        const severityScores = {
            critical: 40,
            high: 30,
            medium: 20,
            low: 10
        };
        risk += severityScores[vulnerability.severity] || 20;

        // Add risk based on reachability
        const reachability = this.calculateReachability(path);
        risk += (reachability / 100) * 40;

        // Add risk if entry point is exposed
        if (path.some(p => this.isEntryPoint(p))) {
            risk += 20;
        }

        return Math.min(100, Math.round(risk));
    }

    /**
     * Identify public API endpoints affected
     */
    identifyPublicAPI(path) {
        const apis = [];

        // Look for route definitions in path
        for (const component of path) {
            if (component.includes('route') || 
                component.includes('controller') ||
                component.includes('api')) {
                apis.push({
                    file: component,
                    type: 'REST API',
                    methods: ['GET', 'POST', 'PUT', 'DELETE'], // Would parse actual routes
                    authentication: 'unknown'
                });
            }
        }

        return apis;
    }

    /**
     * Suggest mitigations for vulnerability path
     */
    suggestMitigations(path, vulnerability) {
        const mitigations = [];

        // Always suggest upgrading vulnerable package
        mitigations.push({
            priority: 'critical',
            action: 'upgrade',
            description: `Upgrade ${path[0]} to a patched version`,
            effort: 'low',
            effectiveness: 'high'
        });

        // Suggest input validation
        if (this.calculateReachability(path) > 50) {
            mitigations.push({
                priority: 'high',
                action: 'validate',
                description: 'Add input validation/sanitization before vulnerable code',
                effort: 'medium',
                effectiveness: 'high'
            });
        }

        // Suggest rate limiting for exposed APIs
        if (path.some(p => this.isEntryPoint(p))) {
            mitigations.push({
                priority: 'medium',
                action: 'protect',
                description: 'Implement rate limiting and WAF rules',
                effort: 'medium',
                effectiveness: 'medium'
            });
        }

        // Suggest monitoring
        mitigations.push({
            priority: 'low',
            action: 'monitor',
            description: 'Add runtime detection and logging for exploit attempts',
            effort: 'low',
            effectiveness: 'low'
        });

        return mitigations;
    }

    /**
     * Generate 3D visualization data for dependency graph
     */
    generate3DVisualization(vulnerablePaths) {
        const nodes = [];
        const edges = [];
        const highlights = [];

        const nodeMap = new Map();
        let nodeId = 0;

        // Create nodes for all dependencies
        for (const [pkg, data] of this.dependencyGraph) {
            const id = nodeId++;
            nodeMap.set(pkg, id);

            nodes.push({
                id,
                label: pkg,
                type: data.type,
                version: data.version,
                vulnerable: vulnerablePaths.some(vp => 
                    vp.path.some(p => p.includes(pkg))
                )
            });
        }

        // Create edges for dependencies
        for (const [pkg, data] of this.dependencyGraph) {
            const fromId = nodeMap.get(pkg);
            
            for (const parent of data.usedIn) {
                // Find package name from file path
                const parentPkg = this.extractPackageFromPath(parent);
                const toId = nodeMap.get(parentPkg);

                if (toId !== undefined) {
                    edges.push({
                        from: fromId,
                        to: toId,
                        type: 'imports'
                    });
                }
            }
        }

        // Highlight exploit paths
        for (const vulnPath of vulnerablePaths) {
            const pathNodeIds = vulnPath.path
                .map(p => nodeMap.get(p))
                .filter(id => id !== undefined);

            highlights.push({
                nodes: pathNodeIds,
                severity: vulnPath.exploitFlow[0]?.severity || 'high',
                riskScore: vulnPath.riskScore,
                glowColor: this.getGlowColor(vulnPath.riskScore)
            });
        }

        return {
            nodes,
            edges,
            highlights,
            stats: {
                totalNodes: nodes.length,
                totalEdges: edges.length,
                vulnerablePaths: highlights.length
            }
        };
    }

    /**
     * Get glow color based on risk score
     */
    getGlowColor(riskScore) {
        if (riskScore >= 80) return '#ff0000'; // Red - Critical
        if (riskScore >= 60) return '#ff6600'; // Orange - High
        if (riskScore >= 40) return '#ffcc00'; // Yellow - Medium
        return '#00ff00'; // Green - Low
    }

    /**
     * Extract package name from file path
     */
    extractPackageFromPath(path) {
        // Extract from paths like: node_modules/package-name/...
        const match = path.match(/node_modules\/([^\/]+)/);
        return match ? match[1] : path;
    }

    /**
     * Analyze all vulnerabilities in project
     */
    analyzeAllVulnerabilities(vulnerabilities) {
        const results = [];

        for (const vuln of vulnerabilities) {
            const paths = this.traceExploitPath(vuln.package, vuln);
            
            results.push({
                vulnerability: vuln,
                exploitPaths: paths,
                maxRiskScore: Math.max(...paths.map(p => p.riskScore), 0),
                publiclyReachable: paths.some(p => p.reachability > 50),
                criticalPaths: paths.filter(p => p.riskScore >= 70).length
            });
        }

        // Sort by risk
        results.sort((a, b) => b.maxRiskScore - a.maxRiskScore);

        return {
            totalVulnerabilities: results.length,
            criticallyReachable: results.filter(r => r.maxRiskScore >= 70).length,
            publiclyExposed: results.filter(r => r.publiclyReachable).length,
            results,
            visualization: this.generate3DVisualization(
                results.flatMap(r => r.exploitPaths)
            )
        };
    }
}

module.exports = new VulnerabilityPathTracer();

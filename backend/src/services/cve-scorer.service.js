/**
 * CVE Impact Scorer Service  
 * Custom algorithm to score risk based on code reachability from public API
 */

const axios = require('axios');

class CVEImpactScorer {
    constructor() {
        this.nvdApiBase = 'https://services.nvd.nist.gov/rest/json/cves/2.0';
        this.osvApiBase = 'https://api.osv.dev/v1';
    }

    /**
     * Calculate comprehensive impact score for CVE
     */
    async calculateImpactScore(cve, exploitPaths, projectContext) {
        // Fetch CVE details from NVD/OSV
        const cveData = await this.fetchCVEData(cve);

        // Calculate base score components
        const baseScore = this.calculateBaseScore(cveData);
        const reachabilityScore = this.calculateReachabilityScore(exploitPaths);
        const exposureScore = this.calculateExposureScore(exploitPaths, projectContext);
        const exploitabilityScore = this.calculateExploitabilityScore(cveData);
        const impactScore = this.calculateBusinessImpact(cveData, projectContext);

        // Weighted composite score
        const compositeScore = (
            baseScore * 0.20 +
            reachabilityScore * 0.30 +
            exposureScore * 0.25 +
            exploitabilityScore * 0.15 +
            impactScore * 0.10
        );

        return {
            cve: cve.id || cve,
            compositeScore: Math.round(compositeScore * 10) / 10,
            breakdown: {
                base: Math.round(baseScore * 10) / 10,
                reachability: Math.round(reachabilityScore * 10) / 10,
                exposure: Math.round(exposureScore * 10) / 10,
                exploitability: Math.round(exploitabilityScore * 10) / 10,
                businessImpact: Math.round(impactScore * 10) / 10
            },
            severity: this.classifySeverity(compositeScore),
            priority: this.calculatePriority(compositeScore, exploitPaths),
            recommendation: this.generateRecommendation(compositeScore, cveData, exploitPaths),
            cveDetails: cveData
        };
    }

    /**
     * Fetch CVE data from national vulnerability database
     */
    async fetchCVEData(cve) {
        try {
            const cveId = typeof cve === 'string' ? cve : cve.id;

            // Try OSV.dev first (faster and more complete for npm)
            const osvResponse = await axios.post(`${this.osvApiBase}/query`, {
                version: '1',
                commit: cveId
            }, { timeout: 5000 });

            if (osvResponse.data && osvResponse.data.vulns) {
                return this.parseOSVData(osvResponse.data.vulns[0]);
            }

            // Fallback to NVD (requires API key in production)
            // const nvdResponse = await axios.get(`${this.nvdApiBase}?cveId=${cveId}`);
            // return this.parseNVDData(nvdResponse.data);

            // If no data found, return defaults
            return this.getDefaultCVEData(cveId);

        } catch (error) {
            console.error('Error fetching CVE data:', error.message);
            return this.getDefaultCVEData(cve);
        }
    }

    /**
     * Parse OSV.dev data format
     */
    parseOSVData(data) {
        if (!data) return this.getDefaultCVEData();

        return {
            id: data.id,
            summary: data.summary || data.details,
            severity: data.database_specific?.severity || 'MODERATE',
            cvssScore: data.database_specific?.cvss_score || 5.0,
            published: data.published,
            modified: data.modified,
            references: data.references || [],
            affected: data.affected || [],
            exploitAvailable: this.checkExploitAvailability(data)
        };
    }

    /**
     * Get default CVE data when fetch fails
     */
    getDefaultCVEData(cveId) {
        return {
            id: cveId || 'UNKNOWN',
            summary: 'CVE data not available',
            severity: 'MODERATE',
            cvssScore: 5.0,
            published: new Date().toISOString(),
            references: [],
            affected: [],
            exploitAvailable: false
        };
    }

    /**
     * Calculate base CVSS score (if not provided)
     */
    calculateBaseScore(cveData) {
        if (cveData.cvssScore) {
            return cveData.cvssScore;
        }

        // Estimate based on severity
        const severityScores = {
            CRITICAL: 9.0,
            HIGH: 7.5,
            MODERATE: 5.0,
            MEDIUM: 5.0,
            LOW: 3.0
        };

        return severityScores[cveData.severity] || 5.0;
    }

    /**
     * Calculate reachability score based on exploit paths
     */
    calculateReachabilityScore(exploitPaths) {
        if (!exploitPaths || exploitPaths.length === 0) {
            return 0;
        }

        let maxReachability = 0;

        for (const path of exploitPaths) {
            let pathScore = 10;

            // Penalize longer paths (less direct = less reachable)
            const pathLength = path.path?.length || 0;
            pathScore -= Math.min(5, pathLength * 0.5);

            // Boost if reaches entry point
            const reachesEntry = path.publicAPI && path.publicAPI.length > 0;
            if (reachesEntry) {
                pathScore += 3;
            }

            // Check for sanitization/validation layers
            const hasSanitization = path.path?.some(p =>
                p.includes('validator') ||
                p.includes('sanitize') ||
                p.includes('middleware')
            );

            if (hasSanitization) {
                pathScore -= 4;
            }

            // Use reachability score from path analysis
            if (path.reachability !== undefined) {
                pathScore = (path.reachability / 100) * 10;
            }

            maxReachability = Math.max(maxReachability, pathScore);
        }

        return Math.max(0, Math.min(10, maxReachability));
    }

    /**
     * Calculate exposure score (how publicly accessible)
     */
    calculateExposureScore(exploitPaths, projectContext) {
        let score = 0;

        // Check if any path reaches public API
        const publicAPIs = exploitPaths.flatMap(p => p.publicAPI || []);

        if (publicAPIs.length > 0) {
            score += 5;

            // Check authentication requirements
            const unauthenticated = publicAPIs.some(api =>
                !api.authentication ||
                api.authentication === 'none' ||
                api.authentication === 'unknown'
            );

            if (unauthenticated) {
                score += 3;
            } else {
                score += 1;
            }

            // Check HTTP methods (POST/PUT more exploitable than GET)
            const writeMethods = publicAPIs.some(api =>
                api.methods && api.methods.some(m => ['POST', 'PUT', 'PATCH', 'DELETE'].includes(m))
            );

            if (writeMethods) {
                score += 2;
            }
        } else {
            // Internal-only vulnerability
            score = 2;
        }

        // Consider deployment environment
        if (projectContext?.environment === 'production') {
            score *= 1.5;
        }

        return Math.min(10, score);
    }

    /**
     * Calculate exploitability score
     */
    calculateExploitabilityScore(cveData) {
        let score = 5; // Base exploitability

        // Check if exploit code is publicly available
        if (cveData.exploitAvailable || this.checkExploitAvailability(cveData)) {
            score += 3;
        }

        // Check exploit complexity (from references)
        const hasPoC = cveData.references?.some(ref =>
            ref.url?.includes('exploit') ||
            ref.url?.includes('poc') ||
            ref.type === 'EXPLOIT'
        );

        if (hasPoC) {
            score += 2;
        }

        // Age of vulnerability (older = more likely to have exploits)
        if (cveData.published) {
            const ageInDays = (Date.now() - new Date(cveData.published)) / (1000 * 60 * 60 * 24);
            if (ageInDays > 365) score += 1; // Over 1 year old
            if (ageInDays > 730) score += 1; // Over 2 years old
        }

        return Math.min(10, score);
    }

    /**
     * Check exploit availability from CVE data
     */
    checkExploitAvailability(cveData) {
        if (!cveData.references) return false;

        return cveData.references.some(ref =>
            ref.url?.includes('exploit-db') ||
            ref.url?.includes('metasploit') ||
            ref.url?.includes('github.com') && ref.url?.includes('exploit') ||
            ref.type === 'EXPLOIT'
        );
    }

    /**
     * Calculate business impact score
     */
    calculateBusinessImpact(cveData, projectContext) {
        let score = 5;

        // Impact categories from CVE
        const impacts = {
            confidentiality: 3,
            integrity: 2,
            availability: 2
        };

        // Estimate based on vulnerability type
        const summary = (cveData.summary || '').toLowerCase();

        if (summary.includes('remote code execution') || summary.includes('rce')) {
            score += impacts.confidentiality + impacts.integrity + impacts.availability;
        } else if (summary.includes('sql injection') || summary.includes('sqli')) {
            score += impacts.confidentiality + impacts.integrity;
        } else if (summary.includes('xss') || summary.includes('cross-site')) {
            score += impacts.confidentiality;
        } else if (summary.includes('dos') || summary.includes('denial of service')) {
            score += impacts.availability;
        }

        // Consider project criticality
        if (projectContext?.criticality === 'high') {
            score *= 1.3;
        }

        return Math.min(10, score);
    }

    /**
     * Classify overall severity
     */
    classifySeverity(score) {
        if (score >= 9.0) return 'CRITICAL';
        if (score >= 7.0) return 'HIGH';
        if (score >= 4.0) return 'MEDIUM';
        return 'LOW';
    }

    /**
     * Calculate remediation priority
     */
    calculatePriority(score, exploitPaths) {
        const severity = this.classifySeverity(score);
        const publiclyReachable = exploitPaths.some(p =>
            p.publicAPI && p.publicAPI.length > 0
        );

        if (severity === 'CRITICAL' && publiclyReachable) {
            return 'P0 - Immediate';
        } else if (severity === 'CRITICAL' || (severity === 'HIGH' && publiclyReachable)) {
            return 'P1 - This Sprint';
        } else if (severity === 'HIGH' || (severity === 'MEDIUM' && publiclyReachable)) {
            return 'P2 - Next Sprint';
        } else if (severity === 'MEDIUM') {
            return 'P3 - Backlog';
        } else {
            return 'P4 - Low Priority';
        }
    }

    /**
     * Generate remediation recommendation
     */
    generateRecommendation(score, cveData, exploitPaths) {
        const recommendations = [];

        // Primary recommendation
        if (score >= 7.0) {
            recommendations.push({
                priority: 'CRITICAL',
                action: 'Upgrade immediately',
                description: 'This vulnerability poses significant risk and should be patched as soon as possible.'
            });
        } else if (score >= 4.0) {
            recommendations.push({
                priority: 'HIGH',
                action: 'Schedule upgrade',
                description: 'Plan to patch this vulnerability in the next sprint.'
            });
        } else {
            recommendations.push({
                priority: 'MEDIUM',
                action: 'Monitor and plan upgrade',
                description: 'Address during regular maintenance cycle.'
            });
        }

        // Add path-specific recommendations
        if (exploitPaths && exploitPaths.length > 0) {
            const publicPath = exploitPaths.find(p => p.publicAPI && p.publicAPI.length > 0);

            if (publicPath) {
                recommendations.push({
                    priority: 'HIGH',
                    action: 'Add input validation',
                    description: 'Implement validation/sanitization at public API entry points.'
                });
            }

            recommendations.push({
                priority: 'MEDIUM',
                action: 'Add monitoring',
                description: 'Implement runtime detection for exploit attempts.'
            });
        }

        // Add alternative mitigations
        recommendations.push({
            priority: 'LOW',
            action: 'Virtual patching',
            description: 'Consider WAF rules or runtime application self-protection (RASP) as interim solution.'
        });

        return recommendations;
    }

    /**
     * Score multiple CVEs and rank by priority
     */
    async scoreMultipleCVEs(vulnerabilities, projectContext) {
        const scores = [];

        for (const vuln of vulnerabilities) {
            const score = await this.calculateImpactScore(
                vuln.cve || vuln.id,
                vuln.exploitPaths || [],
                projectContext
            );

            scores.push({
                ...vuln,
                ...score
            });
        }

        // Sort by composite score (highest first)
        scores.sort((a, b) => b.compositeScore - a.compositeScore);

        return {
            totalVulnerabilities: scores.length,
            criticalCount: scores.filter(s => s.severity === 'CRITICAL').length,
            highCount: scores.filter(s => s.severity === 'HIGH').length,
            mediumCount: scores.filter(s => s.severity === 'MEDIUM').length,
            lowCount: scores.filter(s => s.severity === 'LOW').length,
            averageScore: scores.reduce((sum, s) => sum + s.compositeScore, 0) / scores.length,
            scores
        };
    }

    /**
     * Generate risk matrix visualization data
     */
    generateRiskMatrix(scores) {
        const matrix = {
            critical: { public: [], internal: [] },
            high: { public: [], internal: [] },
            medium: { public: [], internal: [] },
            low: { public: [], internal: [] }
        };

        for (const score of scores) {
            const severity = score.severity.toLowerCase();
            const isPublic = score.breakdown.exposure > 5;

            const category = isPublic ? 'public' : 'internal';
            matrix[severity][category].push(score);
        }

        return matrix;
    }

    // ─── Issue #618: Propagation Weight Calculator ──────────────────────────

    /**
     * Calculate propagation weight for a CVE across a dependency chain.
     * Formula: propagationWeight = CVSS * reachabilityFactor * depthDecay
     * @param {number} cvssScore        - base CVSS 0-10
     * @param {number} reachability     - 0-100 reachability score from path tracer
     * @param {number} depth            - hop depth from vulnerable pkg to affected repo
     * @param {boolean} exploitPublic   - is a public exploit available?
     * @returns {Object} weighted scores and propagation priority
     */
    calculatePropagationWeight(cvssScore, reachability, depth, exploitPublic = false) {
        // Normalize reachability to 0-1
        const reachabilityFactor = Math.min(1, reachability / 100);

        // Depth decay: each hop reduces propagation weight by 20%
        const depthDecay = Math.pow(0.8, Math.max(0, depth - 1));

        // Exploit availability multiplier
        const exploitMultiplier = exploitPublic ? 1.25 : 1.0;

        const propagationWeight = parseFloat(
            (cvssScore * reachabilityFactor * depthDecay * exploitMultiplier).toFixed(3)
        );

        const normalizedTo10 = parseFloat(Math.min(10, propagationWeight).toFixed(2));

        return {
            propagationWeight: normalizedTo10,
            cvssBase: cvssScore,
            reachabilityFactor: parseFloat(reachabilityFactor.toFixed(3)),
            depthDecay: parseFloat(depthDecay.toFixed(3)),
            exploitMultiplier,
            depth,
            propagationSeverity: normalizedTo10 >= 8 ? 'CRITICAL'
                : normalizedTo10 >= 6 ? 'HIGH'
                    : normalizedTo10 >= 4 ? 'MEDIUM' : 'LOW',
            propagationPriority: this._mapWeightToPriority(normalizedTo10)
        };
    }

    /**
     * Score an entire propagation chain — one entry per affected repo.
     * @param {number} cvssScore
     * @param {Array<{repo, depth, reachability}>} affectedChain
     * @param {boolean} exploitPublic
     */
    scorePropagationChain(cvssScore, affectedChain, exploitPublic = false) {
        return affectedChain.map(node => ({
            repo: node.repo,
            depth: node.depth,
            exposedVia: node.exposedVia,
            ...this.calculatePropagationWeight(
                cvssScore,
                node.reachability || 70,
                node.depth,
                exploitPublic
            )
        })).sort((a, b) => b.propagationWeight - a.propagationWeight);
    }

    /**
     * Generate a propagation risk heatmap data structure for frontend charts.
     * @param {Array} scoredChain  - output of scorePropagationChain
     */
    generatePropagationHeatmap(scoredChain) {
        return {
            nodes: scoredChain.map((n, idx) => ({
                id: idx,
                label: n.repo,
                weight: n.propagationWeight,
                severity: n.propagationSeverity,
                depth: n.depth,
                color: n.propagationSeverity === 'CRITICAL' ? '#ef4444'
                    : n.propagationSeverity === 'HIGH' ? '#f97316'
                        : n.propagationSeverity === 'MEDIUM' ? '#eab308'
                            : '#22c55e'
            })),
            maxWeight: scoredChain.length > 0 ? scoredChain[0].propagationWeight : 0,
            criticalCount: scoredChain.filter(n => n.propagationSeverity === 'CRITICAL').length,
            highCount: scoredChain.filter(n => n.propagationSeverity === 'HIGH').length
        };
    }

    _mapWeightToPriority(weight) {
        if (weight >= 8.5) return 'P0 - Immediate';
        if (weight >= 7.0) return 'P1 - This Sprint';
        if (weight >= 5.0) return 'P2 - Next Sprint';
        if (weight >= 3.0) return 'P3 - Backlog';
        return 'P4 - Monitor';
    }
}

module.exports = new CVEImpactScorer();
